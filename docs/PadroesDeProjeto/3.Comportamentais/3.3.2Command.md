
# Padrão Command

## 1. Introdução ao Padrão Command

O padrão Command é um padrão de projeto **comportamental** que converte uma solicitação em um objeto independente que contém todas as informações sobre a solicitação. Essa transformação permite parametrizar métodos com diferentes solicitações, atrasar ou enfileirar a execução de uma solicitação e suportar operações que podem ser desfeitas.<sup>1</sup>

Este padrão é útil para implementar sistemas que precisam de operações como:
- Desfazer/refazer
- Filas de comandos
- Operações de registro (logging)
- Transações

## 1.1. Problema que o Command Resolve

Em sistemas complexos, é comum a necessidade de:
- Enviar solicitações para objetos sem conhecer detalhes da operação
- Executar diferentes comandos no mesmo invocador (ex: botões em UI)
- Evitar acoplamento direto entre invocador e executor

**Exemplo**: Em uma interface gráfica, um botão pode precisar executar diferentes comandos dependendo do contexto. O acoplamento direto torna a manutenção difícil.

**Solução do Command**: Desacoplar o objeto que invoca a operação do objeto que sabe executá-la.

## 1.2. Estrutura e Participantes

### Participantes principais:

| Participante          | Descrição |
|-----------------------|-----------|
| **Command**           | Interface para execução de operação |
| **ConcreteCommand**   | Implementação concreta do comando |
| **Invoker**           | Solicita a execução do comando |
| **Receiver**          | Contém a lógica de negócio real |
| **Client**            | Configura e cria os comandos |

## 1.3. Diagrama UML

<font size="3"><p style="text-align: center"><b>Figura 1:</b> Representação UML do Command</p></font>
<center>

![Command](./assets/uml-command.png)

</center>

<font size="3"><p style="text-align: center"><b>Autor</b>: [Raphaela Guimarães], 2025.</p></font>

## 1.2. Participantes

| Participante        | Descrição                                                                 |
|---------------------|---------------------------------------------------------------------------|
| **Command**         | Interface abstrata que declara o método `execute()` para execução         |
| **ConcreteCommand** | Implementação concreta que vincula uma ação a um Receiver                 |
| **Invoker**         | Solicita a execução do comando através do método `execute()`              |
| **Receiver**        | Contém a lógica de negócio real que será executada pelo comando           |
| **Client**          | Responsável por criar e configurar os objetos Command e seus Receivers    |

## 1.3. Benefícios

**Desacoplamento**  
   - Separa claramente quem invoca a operação (Invoker) de quem a executa (Receiver)
   - Permite alterações em ambos os lados sem impactos diretos

**Comandos Compostos**  
   - Possibilidade de criar:
     - *Macro commands* (combinação de comandos)
     - *Command queues* (filas de execução)
     - *Transactional commands* (execução atômica)

**Undo/Redo**  
   - Padrão natural para implementar:
     ```typescript
     interface Command {
       execute(): void;
       undo(): void;  // Operação reversa
     }
     ```
   - Mantém histórico de estados

**Flexibilidade**  
   - Comandos podem ser:
     - Serializados
     - Logados
     - Agendados
     - Enfileirados

**Extensibilidade**  
   - Novos comandos podem ser adicionados sem modificar:
     - Código existente do Invoker
     - Lógica do Receiver

## 2. Vantagens na Aplicação Prática

### 2.1. Benefícios no Desenvolvimento

**Isolamento de Responsabilidades**  
Separa claramente a lógica de negócio da invocação das operações, permitindo que cada componente se concentre em uma única responsabilidade.

**Flexibilidade Operacional**  
Permite que operações complexas sejam compostas, enfileiradas ou agendadas sem modificar o código existente, seguindo o princípio Open/Closed.

**Gerenciamento de Estado**  
Facilita a implementação de funcionalidades avançadas como desfazer/refazer, histórico de operações e sistemas de auditoria.

### 2.2. Casos de Uso Típicos

**Interface do Usuário**  
Ideal para gerenciar ações de botões e menus onde uma mesma interface pode disparar diferentes comandos conforme o contexto.

**Sistemas Distribuídos**  
Permite o encapsulamento de requisições para execução remota, sendo fundamental em arquiteturas baseadas em mensagens.

**Processamento em Lote**  
Facilita a criação e gerenciamento de filas de comandos para processamento assíncrono ou em background.

## Referências Bibliográficas

1. GAMMA, Erich et al. *Padrões de Projeto: Elementos de Software Orientado a Objetos Reutilizável*. Bookman, 2000.

2. FREEMAN, Eric; ROBSON, Elisabeth. *Use a Cabeça! Padrões de Projetos*. Alta Books, 2009.

3. MARTIN, Robert C. *Clean Architecture: A Craftsman's Guide to Software Structure and Design*. Prentice Hall, 2017.

## Histórico de Versões

| Versão | Data       | Descrição                          | Autor           |
|--------|------------|------------------------------------|-----------------|
| 1.0    | 02/06/2025 | Versão inicial do documento        | Raphaela Guimarães       |
